%% @doc 
%% @author Mark Allen <mrallen1@yahoo.com>
%% @copyright Copyright (C) 2013 Mark Allen
%%
%% Copyright 2013 Mark Allen
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%   http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.

-module(epistula).
-author('Mark Allen <mrallen1@yahoo.com>').

-include("mime.hrl").

-export([
    encode/1,
    new/0,
    new/1,
    new/3,
    new/4,
    to/1,
    to/2,
    from/1,
    from/2,
    add_header/2,
    add_headers/2,
    update_header/2,
    delete_header/2,
    update_message_type/2,
    new_part/0,
    new_part/4,
    add_part/2,
    remove_last_part/1,
    add_plain_text_part/2,
    inline_file/2,
    inline_file/3,
    attach_file/2,
    attach_file/3
    ]
).

%% API

-spec encode(Msg :: #mime_msg{}) -> string().
% @doc Encode a #mime_msg{} record into a string.
%
% This function "renders" the #mime_msg{} record into a string which is suitable
% to pass directly to a mail client.  It encodes all the attached headers and
% then processes associated #mime_part{} records.
% @end
encode(Msg) -> 
    io:format("~p", [Msg]).

-spec new() -> #mime_msg{}.
% @doc Create a new barebones #mime_msg{} record.
%
% This is the bare-bones constructor and returns a message with all of the
% defaults: multipart/mixed and an autogenerated boundary marker. There are no
% default headers or parts.
% @end
new() ->
    #mime_msg{boundary=generate_boundary()}.

-spec new( Type :: atom() ) -> #mime_msg{}.
% @doc Create a new barebones #mime_msg{} record of the specified MIME multipart subtype.
%
% The default subtype is mixed.  Some other common subtypes include:
% <ul>
%   <li>alternative</li>
%   <li>related</li>
%   <li>digest</li>
%   <li>message</li>
% </ul>
%
% You may find the following Wikipedia page useful in learning more about these
% subtypes: [http://en.wikipedia.org/wiki/MIME#Multipart_subtypes]
% @end
new(Type) ->
    update_message_type(new(), Type).

-spec new( To :: string(), From :: string(), Subject :: string() ) -> #mime_msg{}.
% @doc Create a new #mime_msg{} record, populating `To', `From', and `Subject' headers.
new(To, From, Subject) ->
    add_headers(new(), [
        {"To", To},
        {"From", From},
        {"Subject", Subject} ]
    ).

-spec new( To :: string(), From :: string(), Subject :: string(), Body :: string() ) -> #mime_msg{}.
% @doc Syntactic sugar to create a new message, suitable for encoding
%
% This function assumes that the supplied body is US-ASCII text, with a mime
% type of 'text/plain'.
% @end
new(To, From, Subject, Body) ->
    M = new(To, From, Subject),
    add_plain_text_part(M, Body).

-spec to( Msg :: #mime_msg{} ) -> string() | 'undefined'.
% @doc Convenience function to lookup to the value of the `To' header.
to( _Msg = #mime_msg{headers = H} ) ->
    proplists:get_value("To", H).

% @TODO - add email extraction regex for to and from headers.

-spec to( Msg :: #mime_msg{}, To :: string() ) -> #mime_msg{}.
% @doc Convenience function to quickly add or modify the value of the `To' header.
to( Msg, To ) ->
    add_header(Msg, {"To", To}).

-spec add_header( Msg :: #mime_msg{}, Header :: { Key :: atom() | string(), Value :: string() } ) -> #mime_msg{}. 
add_header(Msg = #mime_msg{headers = H}, Header = {Key, _Value}) when is_list(Key) ->
    Msg#mime_msg{headers = lists:keystore(H, 1, Key, Header)};

add_header(Msg, _Header = {Key, Value}) when is_atom(Key) ->
    add_header(Msg, {atom_to_list(Key), Value}).

-spec add_headers( Msg :: #mime_msg{}, Headers :: [{ Key :: string(), Value :: string() }] ) -> #mime_msg{}.
add_headers(Msg = #mime_msg{headers = H}, Headers) when is_list(Headers)->
    Msg#mime_msg{headers = H ++ Headers}.

-spec update_header( Msg :: #mime_msg{}, Header :: { Key :: atom() | string(), Value :: string() } ) -> #mime_msg{}.
update_header(Msg, Header = {Key, _Value}) when is_list(Key) ->
    add_header(Msg, Header);

update_header(Msg, _Header = {Key, Value}) when is_atom(Key) ->
    add_header(Msg, {atom_to_list(Key), Value}).

-spec delete_header( Msg :: #mime_msg{}, Header :: { Key :: atom() | string(), Value :: string() } ) -> #mime_msg{}.
delete_header(Msg = #mime_msg{headers = H}, Header = {Key, _Value}) when is_list(Key) -> 
    Msg#mime_msg{headers = lists:keydelete(H, 1, Key, Header)};

delete_header(Msg, _Header = {Key, Value}) when is_atom(Key) ->
    delete_header(Msg, {atom_to_list(Key), Value}).
    
-spec update_message_type( Msg :: #mime_msg{}, Type :: atom() ) -> #mime_msg{}.
update_message_type(Msg, Type) ->
    Msg#mime_msg{type = Type}.

-spec new_part() -> #mime_part{}.
new_part() -> 
    #mime_part{}.

-spec new_part( 
    Encoding :: { EncodingType :: string(), MimeType :: string(), CharacterSet :: string() },
    Disposition :: atom(),
    Filename :: 'undefined' | string(),
    Data :: string() ) -> #mime_part{}.
new_part(Encoding, Disposition, Filename, Data) ->
    #mime_part{
        encoding = Encoding,
        disposition = Disposition,
        filename = Filename,
        data = Data}.

-spec add_part( Msg :: #mime_msg{}, Part :: #mime_part{} ) -> #mime_msg{}.
add_part(Msg = #mime_msg{parts = P}, Part) ->
    Msg#mime_msg{parts = P ++ [Part]}.

-spec remove_last_part( Msg :: #mime_msg{} ) -> #mime_msg{}.
remove_last_part(Msg = #mime_msg{parts = P}) ->
    Msg#mime_msg{parts = remove_part(P)}.
    
-spec add_plain_text_part( Msg :: #mime_msg{}, Body :: string() ) -> #mime_msg{}.
add_plain_text_part(Msg = #mime_msg{parts = P}, Body) -> 
    Msg#mime_msg{parts = P ++ [ #mime_part{ data = Body } ]}.
    
-spec inline_file( Msg :: #mime_msg{}, Filename :: string() ) -> #mime_msg{}.
inline_file(Msg, Filename) ->
    Guess = guess_mime_type(Filename),
    handle_file(get_mime_type(Guess), Msg, Guess, inline, Filename).

-spec inline_file( Msg :: #mime_msg{}, MimeType :: string(), Filename :: string() ) -> #mime_msg{}.
inline_file(Msg, MimeType, Filename) ->
    handle_file(get_mime_type(MimeType), Msg, MimeType, inline, Filename).

-spec attach_file( Msg :: #mime_msg{}, Filename :: string() ) -> #mime_msg{}.
attach_file(Msg, Filename) ->
    Guess = guess_mime_type(Filename),
    handle_file(get_mime_type(Guess), Msg, Guess, attachment, Filename).

-spec attach_file( Msg :: #mime_msg{}, MimeType :: string(), Filename :: string() ) -> #mime_msg{}.
attach_file(Msg, MimeType, Filename) ->
    handle_file(get_mime_type(MimeType), Msg, MimeType, attachment, Filename).


%% PRIVATE FUNCTIONS

generate_boundary() ->
    <<X:64/big-unsigned-integer>> = crypto:rand_bytes(8),
    "===========" ++ io_lib:format("~12.36.0B", [X]).

remove_part(P) ->
    lists:sublist(P, (length(P) - 1)).

get_file_suffix(Filename) ->
    T = string:tokens(filename:basename(Filename), "."),
    case length(T) of
        1 ->
            Filename;
        _ -> 
            lists:last(T)
    end.

read_file(Filename) ->
    {ok, Data} = file:read_file(Filename),
    Data.

get_env(Setting) ->
    case application:get_env(epistula, Setting) of 
        {ok, V} ->
            V;
        undefined ->
            undefined
    end.

guess_mime_type(Filename) ->
    case get_env(use_file_cmd) of
        true ->
            Cmd = get_env(file_cmd),
            string:strip(os:cmd(Cmd ++ Filename), right, "\n");
        false ->
            mime_type:extension(get_file_suffix(Filename))
    end.
            
get_mime_type(MimeType) ->
    [Type, _SubType] = string:tokens(MimeType, "/"),
    Type.


handle_file("text", Msg, MimeType, Disposition, Filename) ->
    add_part(Msg, new_part(
        {"7bit", MimeType, "US-ASCII"},
        Disposition,
        Filename,
        binary_to_list(read_file(Filename))
    ) );

handle_file(_Type, Msg, MimeType, Disposition, Filename) ->
    add_part(Msg, new_part(
        {"base64", MimeType, "US-ASCII"},
        Disposition,
        Filename,
        base64:encode_to_string(read_file(Filename)))).

