%% @doc 
%% @author Mark Allen <mrallen1@yahoo.com>
%% @copyright Copyright (C) 2013 Mark Allen
%%
%% Copyright 2013 Mark Allen
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%   http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.

-module(epistula).
-author('Mark Allen <mrallen1@yahoo.com>').

-include("mime.hrl").

-export([
    start/0,
    encode/1,
    new/0,
    new/1,
    new/3,
    new/4,
    to/1,
    to/2,
    from/1,
    from/2,
    email/1,
    add_header/2,
    add_headers/2,
    update_header/2,
    delete_header/2,
    update_message_type/2,
    new_part/0,
    new_part/5,
    generate_content_id/0,
    update_content_id/2,
    update_filename/2,
    update_encoding/2,
    update_disposition/2,
    update_data/2,
    add_part/2,
    remove_last_part/1,
    add_plain_text_part/2,
    inline_file/2,
    inline_file/3,
    attach_file/2,
    attach_file/3,
    attach_file/4
    ]
).

%% API

-spec start() -> ok.
% @doc Start the epistula app and all of its dependencies.
start() ->
    application:start(epistula).

-spec encode(Msg :: #mime_msg{}) -> string().
% @doc Encode a message into a string.
%
% This function "renders" the #mime_msg{} record into a string which is suitable
% to pass directly to a mail client.  It encodes all the attached headers and
% then processes associated #mime_part{} records.
% @end
encode(Msg) -> 
    encode_headers(headers(Msg)) ++ "\r\n\r\n" ++
        encode_parts(Msg) ++
        "--" ++ Msg#mime_msg.boundary ++ "--\r\n".

-spec new() -> #mime_msg{}.
% @doc Create a new barebones #mime_msg{} record.
%
% This is the bare-bones constructor and returns a message with all of the
% defaults: multipart/mixed and an autogenerated boundary marker. There are no
% default headers or parts.
% @end
new() ->
    #mime_msg{boundary=generate_boundary()}.

-spec new( Type :: atom() ) -> #mime_msg{}.
% @doc Create a new barebones #mime_msg{} record of the specified MIME multipart subtype.
%
% The default subtype is mixed.  Some other common subtypes include:
% <ul>
%   <li>alternative</li>
%   <li>related</li>
%   <li>digest</li>
%   <li>message</li>
% </ul>
%
% You may find the following Wikipedia page useful in learning more about these
% subtypes: [http://en.wikipedia.org/wiki/MIME#Multipart_subtypes]
% @end
new(Type) ->
    update_message_type(new(), Type).

-spec new( To :: string(), From :: string(), Subject :: string() ) -> #mime_msg{}.
% @doc Create a new #mime_msg{} record, populating `To', `From', and `Subject' headers.
new(To, From, Subject) ->
    add_headers(new(), [
        {"To", To},
        {"From", From},
        {"Subject", Subject} ]
    ).

-spec new( To :: string(), From :: string(), Subject :: string(), Body :: string() ) -> #mime_msg{}.
% @doc Syntactic sugar to create a new message, suitable for encoding
%
% This function assumes that the supplied body is US-ASCII text, with a mime
% type of 'text/plain'.
% @end
new(To, From, Subject, Body) ->
    M = new(To, From, Subject),
    add_plain_text_part(M, Body).

-spec to( Msg :: #mime_msg{} ) -> string() | 'undefined'.
% @doc Convenience function to lookup to the value of the `To' header.
to( _Msg = #mime_msg{headers = H} ) ->
    proplists:get_value("To", H).

-spec to( Msg :: #mime_msg{}, To :: string() ) -> #mime_msg{}.
% @doc Convenience function to quickly add or modify the value of the `To' header.
to( Msg, To ) ->
    add_header(Msg, {"To", To}).

-spec from( Msg :: #mime_msg{} ) -> string() | 'undefined'.
% @doc Convenience function to lookup to the value of the `From' header.
from( _Msg = #mime_msg{headers = H} ) ->
    proplists:get_value("From", H).

-spec from( Msg :: #mime_msg{}, From :: string() ) -> #mime_msg{}.
% @doc Convenience function to quickly add or modify the value of the `From' header.
from( Msg, From ) ->
    add_header(Msg, {"From", From}).

-spec email( S :: string() ) -> string() | 'undefined'.
% @doc Given a string with an email address in it, return <b>only</b> the email address.
%
% This is mostly useful for getting raw email addresses from headers, as in:
%
% `ToEmail = email(to(Msg))'
%
% Returns 'undefined' if no email address is matched.
% @end
email(S) ->
    case re:run(S, "(\\w[-._+'\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,6})", [{capture, first, list}]) of
        {match, Capture} ->
            hd(Capture);
        nomatch ->
            undefined
    end.

-spec add_header( Msg :: #mime_msg{}, Header :: { Key :: atom() | string(), Value :: string() } ) -> #mime_msg{}. 
% @doc Add a header tuple to a message.
%
% This function takes pains not to add a header more than once.  Repeated
% additions will update the value of the header.
% @end
add_header(Msg = #mime_msg{headers = H}, Header = {Key, _Value}) when is_list(Key) ->
    Msg#mime_msg{headers = lists:keystore(H, 1, Key, Header)};

add_header(Msg, _Header = {Key, Value}) when is_atom(Key) ->
    add_header(Msg, {atom_to_list(Key), Value}).

-spec add_headers( Msg :: #mime_msg{}, Headers :: [{ Key :: string(), Value :: string() }] ) -> #mime_msg{}.
% @doc Add a proplist of headers to a message.
%
% This method <b>does not</b> filter duplicates.
% @end
add_headers(Msg = #mime_msg{headers = H}, Headers) when is_list(Headers)->
    Msg#mime_msg{headers = H ++ Headers}.

-spec update_header( Msg :: #mime_msg{}, Header :: { Key :: atom() | string(), Value :: string() } ) -> #mime_msg{}.
% @doc Update a header value in the given message.
update_header(Msg, Header = {Key, _Value}) when is_list(Key) ->
    add_header(Msg, Header);

update_header(Msg, _Header = {Key, Value}) when is_atom(Key) ->
    add_header(Msg, {atom_to_list(Key), Value}).

-spec delete_header( Msg :: #mime_msg{}, Header :: { Key :: atom() | string(), Value :: string() } ) -> #mime_msg{}.
% @doc Remove a header from a message.
delete_header(Msg = #mime_msg{headers = H}, Header = {Key, _Value}) when is_list(Key) -> 
    Msg#mime_msg{headers = lists:keydelete(H, 1, Key, Header)};

delete_header(Msg, _Header = {Key, Value}) when is_atom(Key) ->
    delete_header(Msg, {atom_to_list(Key), Value}).
    
-spec update_message_type( Msg :: #mime_msg{}, Type :: atom() ) -> #mime_msg{}.
% @doc Update a message type.
%
% @see new/1. For more information about MIME subtypes, see here.
% @end
update_message_type(Msg, Type) ->
    Msg#mime_msg{type = Type}.

-spec new_part() -> #mime_part{}.
% @doc Create a new empty part of a MIME message.
% 
% The defaults are:
% <ul>
%   <li>Content-Encoding: 7bit</li>
%   <li>Content-Type: text/plain</li>
%   <li>Charset: US-ASCII</li>
%   <li>Content-Disposition: inline</li>
% </ul>
% @end
new_part() -> 
    #mime_part{}.

-spec new_part( 
    Encoding :: { EncodingType :: string(), MimeType :: string(), CharacterSet :: string() },
    Disposition :: atom(),
    ContentId :: 'undefined' | string(),
    Filename :: 'undefined' | string(),
    Data :: string() ) -> #mime_part{}.
% @doc Create a new message part, specifying all of the part components.
new_part(Encoding, Disposition, ContentId, Filename, Data) ->
    #mime_part{
        encoding = Encoding,
        disposition = Disposition,
        content_id = ContentId,
        filename = Filename,
        data = Data}.

-spec generate_content_id() -> string().
% @doc Generate a cryptographically random 16 byte Content ID.
generate_content_id() ->
   <<X:128/big-unsigned-integer>> = crypto:rand_bytes(16),
   lists:flatten(io_lib:format("~.36.0B", [X])).

-spec update_content_id( Part :: #mime_part{}, ContentId :: string() ) -> #mime_part{}.
% @doc Update a Content ID in a MIME message part.
%
% The value `undefined' can be used to effectively clear any previously set value.
% @end
update_content_id(Part, ContentId) ->
    Part#mime_part{content_id = ContentId}.

-spec update_filename( Part :: #mime_part{}, Filename :: 'undefined' | string() ) -> #mime_part{}.
% @doc Update a filename in a MIME message part.
%
% The value `undefined' can be used to effectively clear any previously set value.
% @end
update_filename(Part, Filename) ->
    Part#mime_part{filename = Filename}.

-spec update_data( Part :: #mime_part{}, Data :: string() ) -> #mime_part{}.
% @doc Update the data in a MIME message part.
update_data(Part, Data) ->
    Part#mime_part{data = Data}.

-spec update_encoding( Part :: #mime_part{}, Encoding :: { EncodingType :: string(), MimeType :: string(), CharSet :: string() } ) -> #mime_part{}.
% @doc Update the encoding tuple in a MIME message part.
update_encoding( Part, Encoding ) ->
    Part#mime_part{encoding = Encoding}.

-spec update_disposition( Part :: #mime_part{}, Disposition :: atom() ) -> #mime_part{}.
% @doc Update the content disposition in a MIME message part.
update_disposition(Part, Disposition) ->
    Part#mime_part{disposition = Disposition}.

-spec add_part( Msg :: #mime_msg{}, Part :: #mime_part{} ) -> #mime_msg{}.
% @doc Add a part to a MIME message.
add_part(Msg = #mime_msg{parts = P}, Part) ->
    Msg#mime_msg{parts = P ++ [Part]}.

-spec remove_last_part( Msg :: #mime_msg{} ) -> #mime_msg{}.
% @doc Remove the last part from the MIME message.
remove_last_part(Msg = #mime_msg{parts = P}) ->
    Msg#mime_msg{parts = remove_part(P)}.
    
-spec add_plain_text_part( Msg :: #mime_msg{}, Body :: string() ) -> #mime_msg{}.
% @doc Convenience function to add a plain text part to a message.
add_plain_text_part(Msg = #mime_msg{parts = P}, Body) -> 
    Msg#mime_msg{parts = P ++ [ #mime_part{ data = Body } ]}.
    
-spec inline_file( Msg :: #mime_msg{}, Filename :: string() ) -> #mime_msg{}.
% @doc Add a file inline to a message.  
%
% The MIME part is guessed either by using the `file(1)' command or by looking at the 
% file extension.  This behavior can be controlled by setting the `use_file_cmd'
% directive to true or false.
%
% The default guess is `application/octet-stream'.
% @end
inline_file(Msg, Filename) ->
    Guess = guess_mime_type(Filename),
    handle_file(get_mime_type(Guess), Msg, Guess, inline, undefined, Filename).

-spec inline_file( Msg :: #mime_msg{}, MimeType :: string(), Filename :: string() ) -> #mime_msg{}.
% @doc Add an inline file with the specified MIME type.
inline_file(Msg, MimeType, Filename) ->
    handle_file(get_mime_type(MimeType), Msg, MimeType, inline, undefined, Filename).

-spec attach_file( Msg :: #mime_msg{}, Filename :: string() ) -> #mime_msg{}.
% @doc Attach a file to a message.  
%
% @see inline_file/2. MIME type guessing works the same as inline_file/2.
% @end
attach_file(Msg, Filename) ->
    Guess = guess_mime_type(Filename),
    handle_file(get_mime_type(Guess), Msg, Guess, attachment, undefined, Filename).

-spec attach_file( Msg :: #mime_msg{}, MimeType :: string(), Filename :: string() ) -> #mime_msg{}.
% @doc Attach a file to a message with the specified MIME type.
attach_file(Msg, MimeType, Filename) ->
    handle_file(get_mime_type(MimeType), Msg, MimeType, attachment, undefined, Filename).

-spec attach_file( Msg :: #mime_msg{}, MimeType :: string(), ContentId :: string(), Filename :: string() ) -> #mime_msg{}.
% @doc Attach a file to a message with the specified MIME type and Content ID.
%
% @see generate_content_id/0. 
attach_file(Msg, MimeType, ContentId, Filename) ->
    handle_file(get_mime_type(MimeType), Msg, MimeType, attachment, ContentId, Filename).

%% PRIVATE FUNCTIONS

generate_boundary() ->
    <<X:64/big-unsigned-integer>> = crypto:rand_bytes(8),
    lists:flatten("===========" ++ io_lib:format("~.36.0B", [X])).

remove_part(P) ->
    lists:sublist(P, (length(P) - 1)).

get_file_suffix(Filename) ->
    T = string:tokens(filename:basename(Filename), "."),
    case length(T) of
        1 ->
            Filename;
        _ -> 
            lists:last(T)
    end.

read_file(Filename) ->
    {ok, Data} = file:read_file(Filename),
    Data.

get_env(Setting) ->
    case application:get_env(epistula, Setting) of 
        {ok, V} ->
            V;
        undefined ->
            undefined
    end.

guess_mime_type(Filename) ->
    case get_env(use_file_cmd) of
        true ->
            Cmd = get_env(file_cmd),
            string:strip(os:cmd(Cmd ++ Filename), right, "\n");
        false ->
            mime_type:extension(get_file_suffix(Filename))
    end.
            
get_mime_type(MimeType) ->
    [Type, _SubType] = string:tokens(MimeType, "/"),
    Type.


handle_file("text", Msg, MimeType, Disposition, ContentId, Filename) ->
    add_part(Msg, new_part(
        {"7bit", MimeType, "US-ASCII"},
        Disposition,
        ContentId,
        Filename,
        binary_to_list(read_file(Filename))
    ) );

handle_file(_Type, Msg, MimeType, Disposition, ContentId, Filename) ->
    add_part(Msg, new_part(
        {"base64", MimeType, "US-ASCII"},
        Disposition,
        ContentId,
        Filename,
        base64:encode_to_string(read_file(Filename)))).


%% HEADERS
%% 
%% Original source:
%% https://github.com/zotonic/zotonic/blob/master/src/smtp/z_email_server.erl#L940
encode_header({Header, [V|Vs]}) when is_list(V) ->
    Hdr = lists:map(fun ({K, Value}) when is_list(K), is_list(Value) ->
                            K ++ "=" ++ Value;
                        ({K, Value}) when is_atom(K), is_list(Value) ->
                            atom_to_list(K) ++ "=" ++ Value;
                        (Value) when is_list(Value) -> Value
                    end,
                    [V|Vs]),
    Header ++ ": " ++ string:join(Hdr, ";\r\n  ");
encode_header({Header, Value})
    when Header =:= "To"; Header =:= "From"; Header =:= "Reply-To"; 
         Header =:= "Cc"; Header =:= "Bcc"; Header =:= "Date";
         Header =:= "Content-Type"; Header =:= "Mime-Version"; Header =:= "MIME-Version";
         Header =:= "Content-Transfer-Encoding" ->
    Value1 = lists:filter(fun(H) -> H >= 32 andalso H =< 126 end, Value),
    Header ++ ": " ++ Value1;
encode_header({Header, Value}) when is_list(Header), is_list(Value) ->
    % Encode all other headers according to rfc2047
    Header ++ ": " ++ rfc2047:encode(Value);
encode_header({Header, Value}) when is_atom(Header), is_list(Value) ->
    atom_to_list(Header) ++ ": " ++ rfc2047:encode(Value).

encode_headers(Headers) ->
    string:join(lists:map(fun encode_header/1, Headers), "\r\n").


%% Encode message parts
%% 
%% Based on code from:
%% https://github.com/archaelus/esmtp/blob/master/src/esmtp_mime.erl#L101
encode_parts(#mime_msg{parts=Parts, boundary=Boundary}) ->
    lists:map(fun(P) -> encode_part(P,Boundary) end, Parts).

encode_part(#mime_part{data=Data} = P, Boundary) ->
    "--" ++ Boundary ++ "\r\n" ++
    encode_headers(part_headers(P)) ++ "\r\n\r\n" ++
    Data ++ "\r\n";

encode_part(Msg = #mime_msg{}, Boundary) ->
    "--" ++ Boundary ++ "\r\n" ++ encode(Msg) ++ "\r\n".

part_headers(#mime_part{encoding={Enc, MimeType, Charset},
                        content_id=undefined,
                        filename=undefined}) ->
    [{"Content-Transfer-Encoding", Enc},
     {"Content-Type", [MimeType, {charset, Charset}]}];

part_headers(#mime_part{disposition=D, 
                        encoding={Enc, MimeType, Charset},
                        content_id = undefined,
                        filename=Filename}) when D == inline; D == attachment ->
    [{"Content-Transfer-Encoding", Enc},
     {"Content-Type", [MimeType, "charset=" ++ Charset ++ ",name=" ++ Filename]},
     {"Content-Disposition", [atom_to_list(D), 
                              {"filename", 
                              Filename}]}];

part_headers(#mime_part{disposition=D, 
                        encoding={Enc, MimeType, Charset},
                        content_id = ContentId,
                        filename=Filename}) when D == inline; D == attachment ->
    [{"Content-Transfer-Encoding", Enc},
     {"Content-Type", [MimeType, "charset=" ++ Charset ++ ",name=" ++ Filename]},
     {"Content-Id", ContentId},
     {"Content-Disposition", [atom_to_list(D), 
                              {"filename", 
                              Filename}]}].

headers(#mime_msg{headers=H, boundary=Boundary}) ->
    H ++ [{"MIME-Version", "1.0"},
          {"Content-Type", ["multipart/mixed", 
                            "boundary=\"" ++ Boundary ++ "\""]}].
